#include "utf32_testdata.h"
#include <span>
#include <vector>
#include <cstdint>
#include <array>


//
// UTF-32 Sequences
//
std::span<std::vector<std::uint32_t>> get_valid_utf32_sequences() {
	static std::array<std::vector<std::uint32_t>,4> td {{
		{},
		{0x00u},
		{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
		// Lowest-highest possible value + the two values directly below and above the "surrogate gap"
		{0x0u, 0x1u, 0xFFu,	0xABCDu, 0xD7FFu, 0xE000u, 0x10FFFFu},
	}};
	return td;
}

std::span<testdata_invalid_utf32> get_invalid_utf32_sequences() {
	static std::array<testdata_invalid_utf32,10> td {{
		// Totally invalid
		{
			{0xD800u},
			{0xFFFDu},
			{0xFFFDu}
		},
		{
			{0xD800u, 0xD801u, 0xD802u, 0xDFFFu, 0x110000u, 0x110001u},
			{0xFFFDu},
			{0xFFFDu, 0xFFFDu, 0xFFFDu, 0xFFFDu, 0xFFFDu,   0xFFFDu}
		},
		// Valid but with a single invalid code unit
		{  // Invalid at the start
			{0x110000u, 0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
			{0xFFFDu,   0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
			{0xFFFDu,   0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
		},
		{  // Invalid at the end
			{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0x110000u},
			{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu  },
			{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu  },
		},
		{  // Invalid in the middle
			{0x0Du, 0x2Au, 0x3Bu, 0x110000u, 0x42u, 0xAAu, 0xFFu},
			{0x0Du, 0x2Au, 0x3Bu, 0xFFFDu,   0x42u, 0xAAu, 0xFFu},
			{0x0Du, 0x2Au, 0x3Bu, 0xFFFDu,   0x42u, 0xAAu, 0xFFu},
		},
		// Valid but with two invalid code units grouped together
		{  // Invalid at the start
			{0xD800u, 0xD801u, 0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
			{0xFFFDu,          0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
			{0xFFFDu, 0xFFFDu, 0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu},
		},
		{  // Invalid in the middle
			{0x0Du, 0x2Au, 0x3Bu, 0xD800u, 0xD801u, 0x42u, 0xAAu, 0xFFu},
			{0x0Du, 0x2Au, 0x3Bu, 0xFFFDu,          0x42u, 0xAAu, 0xFFu},
			{0x0Du, 0x2Au, 0x3Bu, 0xFFFDu, 0xFFFDu, 0x42u, 0xAAu, 0xFFu},
		},
		{  // Invalid at the end
			{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xD800u, 0xD801u},
			{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu,        },
			{0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu, 0xFFFDu},
		},
		{  // Starts with a valid followed immediately by an single invalid
			{0x0Du, 0xD801u, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xD800u, 0xD801u},
			{0x0Du, 0xFFFDu, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu,        },
			{0x0Du, 0xFFFDu, 0x3Bu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu, 0xFFFDu},
		},
		{  // Starts with a valid followed immediately by an double invalid
			{0x0Du, 0x110001u, 0xD801u, 0x42u, 0xAAu, 0xFFu, 0xD800u, 0xD801u},
			{0x0Du, 0xFFFDu,            0x42u, 0xAAu, 0xFFu, 0xFFFDu,        },
			{0x0Du, 0xFFFDu,   0xFFFDu, 0x42u, 0xAAu, 0xFFu, 0xFFFDu, 0xFFFDu},
		},
	}};
	return td;
}


//
// Single-dword test data
//
std::span<std::uint32_t> get_valid_utf32_code_unit_testdata() {
	static std::array<std::uint32_t,12> td {
		0x0u, 0x1u,
		0x0Du, 0x2Au, 0x3Bu, 0x42u, 0xAAu, 0xFFu,
		0xABCDu,
		0xD7FFu, // Highest value before the lowest utf16 surrogate
		0xE000u, // Lowest value after the highest utf16 surrogate
		0x10FFFFu // Any UTF-32 code unit greater than 0x10FFFF is ill-formed
	};
	return td;
}

std::span<std::uint32_t> get_invalid_utf32_code_unit_testdata() {
	static std::array<std::uint32_t,16> td {
		0xD800u,  // lowest utf16 surrogate
		0xD801u, 0xD900u, 0xD95Eu, 0xDA00u, 0xDB00u, 0xDC00u, 0xDE00u, 0xDF00u,
		0xDFFFu,  // highest utf16 surrogate
		0x110000, // Any UTF-32 code unit greater than 0x10FFFF is ill-formed
		0x110001u, 0x11A000u, 0x210000u, 0xBCDEF0u,
		0xFFFFFFFFu,  // uint max
	};
	return td;
}

