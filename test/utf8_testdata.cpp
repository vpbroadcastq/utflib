#include "utf8_testdata.h"

#include <vector>
#include <cstdint>
#include <array>

std::vector<test_data> g_td_valid {
	{
		.d = {0x73, 0x74, 0x64, 0x3A, 0x3A, 0x66, 0x72, 0x65, 0x61, 0x64, 0x0D, 0x0A,
			0x20, 0x43, 0x2B, 0x2B},
		.codepoints = {0x73, 0x74, 0x64, 0x3A, 0x3A, 0x66, 0x72, 0x65, 0x61, 0x64, 0x0D, 0x0A,
			0x20, 0x43, 0x2B, 0x2B},
		.idx_init_invalid = 0,
		.is_valid = true
	},
	{	.d = {0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
			0x74, 0x20, 0x6C, 0x69},
		.codepoints = {0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
			0x74, 0x20, 0x6C, 0x69},
		.idx_init_invalid = 0,
		.is_valid = true
	},
	{	.d = {0x3C, 0x20, 0x31, 0x20, 0x3C, 0x3C, 0x20, 0x27, 0x20, 0x27, 0x20, 0x3C,
			0x3C, 0x20, 0x32, 0x20},
		.codepoints = {0x3C, 0x20, 0x31, 0x20, 0x3C, 0x3C, 0x20, 0x27, 0x20, 0x27, 0x20, 0x3C,
			0x3C, 0x20, 0x32, 0x20},
		.idx_init_invalid = 0,
		.is_valid = true
	},
};

std::vector<test_data> g_td_invalid {
	{
		.d = {0xC3, 0x28},
		.codepoints = {},  // C3 is an invalid initial byte
		.idx_init_invalid = 0,
		.is_valid = false
	},
	{
		.d = {0x0D, 0x0A, 0xC3, 0x28},
		.codepoints = {0x0D, 0x0A},  // C3 is an invalid initial byte
		.idx_init_invalid = 2,
		.is_valid = false
	},
	{
		.d = {0xE2, 0x28, 0xA1},  // E2=>3 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 1,
		.is_valid = false
	},
	{
		.d = {0xE2, 0xA1, 0x28},  // E2=>3 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 2,
		.is_valid = false
	},
	{
		.d = {0xF0, 0x28, 0x8C, 0xBC},  // F0=>4 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 1,
		.is_valid = false
	},
	{
		.d = {0xF0, 0x8C, 0xBC, 0x28},  // F0=>4 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 3,
		.is_valid = false
	},
	{
		.d = {0x0D, 0x0A, 0xF0, 0x8C, 0xBC, 0x28},  // F0=>4 byte seq but 28 is an invalid secondary byte
		.codepoints = {0x0D, 0x0A},
		.idx_init_invalid = 5,
		.is_valid = false
	},
};


//
// Sequences
//
std::span<testdata_valid_utf8_utf32> get_valid_utf8_utf32_sequences() {
	static std::array<testdata_valid_utf8_utf32,9> d {{
		// Special
		{
			{},
			{}
		},
		// Pure ascii
		{
			{0x00},
			{0x00}
		},
		{
			{0x0D, 0x0A},
			{0x0D, 0x0A}
		},
		{
			{0x64, 0x28, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 0x20, 0x33, 0x2E, 0x31, 0x30, 0x29, 0x0D, 0x0A},
			{0x64, 0x28, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 0x20, 0x33, 0x2E, 0x31, 0x30, 0x29, 0x0D, 0x0A}
		},
		// With 4-byte codepoint examples.
		{
			{0x61, 0x62, 0x63, 0x20, 0xF0, 0x9F, 0x98, 0x80, 0x64, 0x65, 0x66},
			{0x61, 0x62, 0x63, 0x20, 0x1F600,                0x64, 0x65, 0x66}
		},
		{
			{0xF0, 0x9F, 0x99, 0x83, 0x61, 0x62, 0x63, 0x20, 0xF0, 0x9F, 0x98, 0x80, 0x64, 0x65, 0x66},
			{0x1F643,                0x61, 0x62, 0x63, 0x20, 0x1F600,                0x64, 0x65, 0x66}
		},
		{
			{0xF0, 0x9F, 0x99, 0x83, 0x61, 0x62, 0xF0, 0x9F, 0x98, 0x80, 0x64, 0x66, 0xF0, 0x9F, 0xA7, 0xBF},
			{0x1F643,                0x61, 0x62, 0x1F600,                0x64, 0x66, 0x1F9FF}
		},
		{
			{0xF0, 0x9F, 0x99, 0x83},
			{0x1F643,              }
		},
		{
			{0xF0, 0x9F, 0x99, 0x83, 0xF0, 0x9F, 0x98, 0x80, 0xF0, 0x9F, 0xA7, 0xBF},
			{0x1F643,                0x1F600,                0x1F9FF}
		},
	}};
	return d;
}

std::span<testdata_invalid_utf8_utf32> get_invalid_utf8_utf32_sequences() {
	static std::array<testdata_invalid_utf8_utf32,14> d {{
		{
			// Example from the unicode standard
			// 0xC2 is a valid lb and indicates a 2-byte sequence.  The single tb must be on [0x80,0xBF]
			{0xC2,   0x41, 0x42},
			{0xFFFD, 0x41, 0x42},
			{0xFFFD, 0x41, 0x42}
		},
		{
			{0xE0,   0x81,    0x82,   0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 0x20, 0x33, 0x2E, 0x31, 0x30, 0x29, 0x0D, 0x0A},
			{0xFFFD,                  0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 0x20, 0x33, 0x2E, 0x31, 0x30, 0x29, 0x0D, 0x0A},
			{0xFFFD, 0xFFFD,  0xFFFD, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 0x20, 0x33, 0x2E, 0x31, 0x30, 0x29, 0x0D, 0x0A},
		},
		// With 4-byte codepoint examples.
		{
			{0x61, 0x62, 0x63, 0x20, 0xF0, 0x9F, 0x98, 0x80, 0xE0,   0x81,   0x82  },
			{0x61, 0x62, 0x63, 0x20, 0x1F600,                0xFFFD                },
			{0x61, 0x62, 0x63, 0x20, 0x1F600,                0xFFFD, 0xFFFD, 0xFFFD}
		},
		{
			{0xF0, 0x9F, 0x99, 0x83, 0x61, 0xED,    0xEE,   0xF0,    0xF0, 0x9F, 0x98, 0x80, 0x64, 0x65, 0x66},
			{0x1F643,                0x61, 0xFFFD,                   0x1F600,                0x64, 0x65, 0x66},
			{0x1F643,                0x61, 0xFFFD,  0xFFFD, 0xFFFD,  0x1F600,                0x64, 0x65, 0x66}
		},
		{
			{0xF0, 0x9F, 0x99, 0x83, 0x61, 0x62, 0xF0, 0x9F, 0x98, 0x80, 0xC1,      0xF4,    0xF0, 0x9F, 0xA7, 0xBF},
			{0x1F643,                0x61, 0x62, 0x1F600,                0xFFFD,             0x1F9FF},
			{0x1F643,                0x61, 0x62, 0x1F600,                0xFFFD,    0xFFFD,  0x1F9FF}
		},
		{
			{0xF0, 0x9F, 0x99, 0xC2,   0x00},
			{0xFFFD,                   0x00},
			{0xFFFD,           0xFFFD, 0x00}
		},
		{
			{0xE1, 0x80, 0xE2,   0xF0, 0x91, 0x92, 0xF1, 0xBF, 0x41},  // Table 3-11 unicode standard
			{0xFFFD,                                           0x41},
			{0xFFFD,     0xFFFD, 0xFFFD,           0xFFFD,     0x41}
		},
		// Completely invalid
		{
			{0xC0},
			{0xFFFD},
			{0xFFFD}
		},
		{
			{0x80  },
			{0xFFFD},
			{0xFFFD}
		},
		{
			{0xF4,    0x90,   0xA1,   0xBF  },
			{0xFFFD                         },
			{0xFFFD,  0xFFFD, 0xFFFD, 0xFFFD}
		},
		{
			{0xF0, 0x91, 0xA1},  // Would be valid, but missing the last byte
			{0xFFFD          },
			{0xFFFD          }
		},
		{
			{0xC3  },  // Would be valid, but missing the last byte
			{0xFFFD},
			{0xFFFD}
		},
		{
			{0xE3, 0xA0},  // Would be valid, but missing the last byte
			{0xFFFD    },
			{0xFFFD    }
		},
		{
			{0xF0, 0x9F, 0xC1,   0x83,   0xF0, 0x92, 0x98, 0xF4,   0xF4,   0x9F,     0xA7,   0xBF  },
			{0xFFFD                                                                                },
			{0xFFFD,     0xFFFD, 0xFFFD, 0xFFFD,           0xFFFD, 0xFFFD, 0xFFFD,   0xFFFD, 0xFFFD}
		},
	}};
	return d;
}

//
// Single-byte tests
//
std::span<testdata_utf8_leading_bytes> get_valid_utf8_leading_byte_testdata() {
	static std::array<testdata_utf8_leading_bytes,20> d {{
		// 1 byte
		{0x00,1}, {0x01,1},
		{0x7E,1}, {0x7F,1},
		// 2 byte
		{0xC2,2}, {0xC3,2},
		{0xDE,2}, {0xDF,2},
		// 3 byte
		{0xE0,3}, {0xE1,3},
		{0xEB,3}, {0xEC,3},
		{0xED,3}, {0xEE,3},
		{0xEF,3},
		// 4 byte
		{0xF0,4}, {0xF1,4},
		{0xF2,4}, {0xF3,4},
		{0xF4,4}

	}};
	return d;
}

// Examples of invalid leading bytes
std::span<std::uint8_t> get_invalid_utf8_leading_byte_testdata() {
	static std::array<std::uint8_t,27> d {
		0x80, 0x81, 0x82, 0x8E, 0x8F,
		0x90, 0x91, 0x9A, 0x9E, 0x9F,
		0xA0, 0xA1, 0xAA, 0xAE, 0xAF,
		0xB0, 0xB1, 0xBA, 0xBE, 0xBF,
		0xC0, 0xC1,
		0xF5, 0xF6, 0xF7, 0xFE, 0xFF
	};
	return d;
}

// Examples of invalid third and fourth bytes
std::span<std::uint8_t> get_invalid_utf8_third_and_fourth_byte_testdata() {
	static std::array<std::uint8_t,72> d {
		0x00, 0x01, 0x02, 0x0D, 0x0E, 0x0F,
		0x10, 0x11, 0x12, 0x1D, 0x1E, 0x1F,
		0x20, 0x21, 0x22, 0x2D, 0x2E, 0x2F,
		0x30, 0x31, 0x32, 0x3D, 0x3E, 0x3F,
		0x40, 0x41, 0x42, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x5D, 0x5E, 0x5F,
		0x60, 0x61, 0x62, 0x6D, 0x6E, 0x6F,
		0x70, 0x71, 0x72, 0x7D, 0x7E, 0x7F,
		0xC0, 0xC1, 0xC2, 0xCD, 0xCE, 0xCF,
		0xD0, 0xD1, 0xD2, 0xDD, 0xDE, 0xDF,
		0xE0, 0xE1, 0xE2, 0xED, 0xEE, 0xEF,
		0xF0, 0xF1, 0xF2, 0xFD, 0xFE, 0xFF,
	};
	return d;
}

// Examples of valid third and fourth bytes
std::span<std::uint8_t> get_valid_utf8_third_and_fourth_byte_testdata() {
	static std::array<std::uint8_t,24> d {
		0x80, 0x81, 0x82, 0x8D, 0x8E, 0x8F,
		0x90, 0x91, 0x92, 0x9D, 0x9E, 0x9F,
		0xA0, 0xA1, 0xA2, 0xAD, 0xAE, 0xAF,
		0xB0, 0xB1, 0xB2, 0xBD, 0xBE, 0xBF,
	};
	return d;
}


std::span<testdata_utf8_first_and_second_bytes> get_valid_first_and_second_utf8_byte_pairs() {
	static std::array<testdata_utf8_first_and_second_bytes,75> d {{
		// U+0080..U+07FF
		{0xC2, 0x80}, {0xC2, 0x81}, {0xC2, 0xA1}, {0xC2, 0xBE}, {0xC2, 0xBF},
		{0xD2, 0x80}, {0xD2, 0x81}, {0xD2, 0xA1}, {0xD2, 0xBE}, {0xD2, 0xBF},
		{0xDF, 0x80}, {0xDF, 0x81}, {0xDF, 0xA1}, {0xDF, 0xBE}, {0xDF, 0xBF},
		// U+0800..U+0FFF
		{0xE0, 0xA0}, {0xE0, 0xA1}, {0xE0, 0xAF}, {0xE0, 0xBE}, {0xE0, 0xBF},
		// U+1000..U+CFFF
		{0xE1, 0x80}, {0xE1, 0x81}, {0xE1, 0xA1}, {0xE1, 0xBE}, {0xE1, 0xBF},
		{0xE2, 0x80}, {0xE2, 0x81}, {0xE2, 0xA1}, {0xE2, 0xBE}, {0xE2, 0xBF},
		{0xEC, 0x80}, {0xEC, 0x81}, {0xEC, 0xA1}, {0xEC, 0xBE}, {0xEC, 0xBF},
		// U+D000..U+D7FF
		{0xED, 0x80}, {0xED, 0x81}, {0xED, 0x87}, {0xED, 0x97}, {0xED, 0x9F},
		// U+E000..U+FFFF
		{0xEE, 0x80}, {0xEE, 0x81}, {0xEE, 0xA1}, {0xEE, 0xBE}, {0xEE, 0xBF},
		{0xEF, 0x80}, {0xEF, 0x81}, {0xEF, 0xA1}, {0xEF, 0xBE}, {0xEF, 0xBF},
		// U+10000..U+3FFFF
		{0xF0, 0x90}, {0xF0, 0x91}, {0xF0, 0xA7}, {0xF0, 0xBE}, {0xF0, 0xBF},
		// U+40000..U+FFFFF
		{0xF1, 0x80}, {0xF1, 0x81}, {0xF1, 0xA1}, {0xF1, 0xBE}, {0xF1, 0xBF},
		{0xF2, 0x80}, {0xF2, 0x81}, {0xF2, 0xA1}, {0xF2, 0xBE}, {0xF2, 0xBF},
		{0xF3, 0x80}, {0xF3, 0x81}, {0xF3, 0xA1}, {0xF3, 0xBE}, {0xF3, 0xBF},
		// U+100000..U+10FFFF
		{0xF4, 0x80}, {0xF4, 0x81}, {0xF4, 0x87}, {0xF4, 0x8E}, {0xF4, 0x8F},
	}};
	return d;
}

// The leading byte is always valid but the associated trailing byte is always invalid (for that
// leading byte).
std::span<testdata_utf8_first_and_second_bytes> get_invalid_first_and_second_utf8_byte_pairs() {
	static std::array<testdata_utf8_first_and_second_bytes,75> d {{
		// U+0080..U+07FF
		{0xC2, 0x70}, {0xC2, 0x71}, {0xC2, 0x7F}, {0xC2, 0xC0}, {0xC2, 0xCF},
		{0xD2, 0x70}, {0xD2, 0x71}, {0xD2, 0x7F}, {0xD2, 0xC0}, {0xD2, 0xCF},
		{0xDF, 0x70}, {0xDF, 0x71}, {0xDF, 0x7F}, {0xDF, 0xC0}, {0xDF, 0xCF},
		// U+0800..U+0FFF
		{0xE0, 0x90}, {0xE0, 0x9F}, {0xE0, 0xC0}, {0xE0, 0xCE}, {0xE0, 0xCF},
		// U+1000..U+CFFF
		{0xE1, 0x70}, {0xE1, 0x71}, {0xE1, 0x7F}, {0xE1, 0xC0}, {0xE1, 0xCF},
		{0xE2, 0x70}, {0xE2, 0x71}, {0xE2, 0x7F}, {0xE2, 0xC0}, {0xE2, 0xCF},
		{0xEC, 0x70}, {0xEC, 0x71}, {0xEC, 0x7F}, {0xEC, 0xC0}, {0xEC, 0xCF},
		// U+D000..U+D7FF
		{0xED, 0x70}, {0xED, 0x71}, {0xED, 0x7F}, {0xED, 0xA0}, {0xED, 0xAF},
		// U+E000..U+FFFF
		{0xEE, 0x70}, {0xEE, 0x71}, {0xEE, 0x7F}, {0xEE, 0xC0}, {0xEE, 0xCF},
		{0xEF, 0x70}, {0xEF, 0x71}, {0xEF, 0x7F}, {0xEF, 0xC0}, {0xEF, 0xCF},
		// U+10000..U+3FFFF
		{0xF0, 0x80}, {0xF0, 0x87}, {0xF0, 0x8F}, {0xF0, 0xC0}, {0xF0, 0xCF},
		// U+40000..U+FFFFF
		{0xF1, 0x70}, {0xF1, 0x71}, {0xF1, 0x7F}, {0xF1, 0xC0}, {0xF1, 0xCF},
		{0xF2, 0x70}, {0xF2, 0x71}, {0xF2, 0x7F}, {0xF2, 0xC0}, {0xF2, 0xCF},
		{0xF3, 0x70}, {0xF3, 0x71}, {0xF3, 0x7F}, {0xF3, 0xC0}, {0xF3, 0xCF},
		// U+100000..U+10FFFF
		{0xF4, 0x70}, {0xF4, 0x7F}, {0xF4, 0x90}, {0xF4, 0x91}, {0xF4, 0x9F},
	}};
	return d;
}


//
// Single codepoint test data
//
std::span<testdata_valid_utf8> get_valid_utf8_single_cp_testdata() {
	static std::array<testdata_valid_utf8,18> d {
		// 1 byte
		testdata_valid_utf8 {{0x00, 0x00, 0x00, 0x00}, 0x00, 1},
		testdata_valid_utf8 {{0x20, 0x00, 0x00, 0x00}, 0x20, 1},
		testdata_valid_utf8 {{0x7E, 0x00, 0x00, 0x00}, 0x7E, 1},
		testdata_valid_utf8 {{0x7F, 0x00, 0x00, 0x00}, 0x7F, 1},
		// 2 byte
		testdata_valid_utf8 {{0xC2, 0x80, 0x00, 0x00}, 0x80, 2},
		testdata_valid_utf8 {{0xC2, 0xA0, 0x00, 0x00}, 0xA0, 2},
		testdata_valid_utf8 {{0xC2, 0xBF, 0x00, 0x00}, 0xBF, 2},
		testdata_valid_utf8 {{0xC3, 0xBF, 0x00, 0x00}, 0xFF, 2},
		testdata_valid_utf8 {{0xCC, 0x9A, 0x00, 0x00}, 0x31A, 2},
		testdata_valid_utf8 {{0xCF, 0xBF, 0x00, 0x00}, 0x3FF, 2},
		// 3 byte
		testdata_valid_utf8 {{0xE0, 0xB1, 0xA9, 0x00}, 0xC69, 3},
		testdata_valid_utf8 {{0xEF, 0xB8, 0x99, 0x00}, 0xFE19, 3},
		testdata_valid_utf8 {{0xEF, 0xB8, 0xA8, 0x00}, 0xFE28, 3},
		testdata_valid_utf8 {{0xED, 0x9E, 0xB0, 0x00}, 0xD7B0, 3},
		testdata_valid_utf8 {{0xEE, 0x80, 0x80, 0x00}, 0xE000, 3},
		//4 byte
		testdata_valid_utf8 {{0xF3, 0xA5, 0x96, 0xB8}, 0xE55B8, 4},
		testdata_valid_utf8 {{0xF0, 0x9F, 0x9F, 0x92}, 0x1F7D2, 4},
		testdata_valid_utf8 {{0xF0, 0x9F, 0x9D, 0x93}, 0x1F753, 4},
	};
	return d;
}

std::span<testdata_invalid_utf8> get_invalid_utf8_single_cp_testdata() {
	static std::array<testdata_invalid_utf8,29> d {
		// Invalid leading byte
		testdata_invalid_utf8 {{0x95}},
		testdata_invalid_utf8 {{0xA1}},
		testdata_invalid_utf8 {{0xB2}},
		testdata_invalid_utf8 {{0xC0}},
		testdata_invalid_utf8 {{0xC1}},
		testdata_invalid_utf8 {{0xF5}},
		testdata_invalid_utf8 {{0xFF}},
		// Leading byte indicates 1 byte
		testdata_invalid_utf8 {{0x00, 0x00, 0x00, 0x00}},
		testdata_invalid_utf8 {{0x20, 0x00}},
		testdata_invalid_utf8 {{0x7E, 0x00, 0x00}},
		testdata_invalid_utf8 {{0x7F, 0x00, 0x00, 0x00}},
		// Leading byte indicates 2 bytes
		testdata_invalid_utf8 {{0xC2}},
		testdata_invalid_utf8 {{0xC2, 0xA0, 0x00}},
		testdata_invalid_utf8 {{0xC2, 0xBF, 0x00, 0x00}},
		testdata_invalid_utf8 {{0xC3}},
		testdata_invalid_utf8 {{0xCC, 0x9A, 0x00}},
		testdata_invalid_utf8 {{0xCF, 0xBF, 0x00, 0x00}},
		// Leading byte indicates 3 bytes
		testdata_invalid_utf8 {{0xE0}},
		testdata_invalid_utf8 {{0xEF, 0xB8}},
		testdata_invalid_utf8 {{0xEF, 0xB8, 0xA8, 0x00}},
		testdata_invalid_utf8 {{0xED}},
		testdata_invalid_utf8 {{0xEE, 0x80}},
		// Leading byte indicates 4 bytes
		testdata_invalid_utf8 {{0xF3}},
		testdata_invalid_utf8 {{0xF3, 0xA5}},
		testdata_invalid_utf8 {{0xF3, 0xA5, 0x96}},
		testdata_invalid_utf8 {{0xF0}},
		testdata_invalid_utf8 {{0xF0, 0x9F}},
		testdata_invalid_utf8 {{0xF0, 0x9F, 0x9D, 0x93, 0x00}},
	};
	return d;
}


