#include <vector>
#include <cstdint>
#include <array>
#include "test_data.h"

std::vector<test_data> g_td_valid {
	{
		.d = {0x73, 0x74, 0x64, 0x3A, 0x3A, 0x66, 0x72, 0x65, 0x61, 0x64, 0x0D, 0x0A,
			0x20, 0x43, 0x2B, 0x2B},
		.codepoints = {0x73, 0x74, 0x64, 0x3A, 0x3A, 0x66, 0x72, 0x65, 0x61, 0x64, 0x0D, 0x0A,
			0x20, 0x43, 0x2B, 0x2B},
		.idx_init_invalid = 0,
		.is_valid = true
	},
	{	.d = {0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
			0x74, 0x20, 0x6C, 0x69},
		.codepoints = {0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
			0x74, 0x20, 0x6C, 0x69},
		.idx_init_invalid = 0,
		.is_valid = true
	},
	{	.d = {0x3C, 0x20, 0x31, 0x20, 0x3C, 0x3C, 0x20, 0x27, 0x20, 0x27, 0x20, 0x3C,
			0x3C, 0x20, 0x32, 0x20},
		.codepoints = {0x3C, 0x20, 0x31, 0x20, 0x3C, 0x3C, 0x20, 0x27, 0x20, 0x27, 0x20, 0x3C,
			0x3C, 0x20, 0x32, 0x20},
		.idx_init_invalid = 0,
		.is_valid = true
	},
};

std::vector<test_data> g_td_invalid {
	{
		.d = {0xC3, 0x28},
		.codepoints = {},  // C3 is an invalid initial byte
		.idx_init_invalid = 0,
		.is_valid = false
	},
	{
		.d = {0x0D, 0x0A, 0xC3, 0x28},
		.codepoints = {0x0D, 0x0A},  // C3 is an invalid initial byte
		.idx_init_invalid = 2,
		.is_valid = false
	},
	{
		.d = {0xE2, 0x28, 0xA1},  // E2=>3 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 1,
		.is_valid = false
	},
	{
		.d = {0xE2, 0xA1, 0x28},  // E2=>3 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 2,
		.is_valid = false
	},
	{
		.d = {0xF0, 0x28, 0x8C, 0xBC},  // F0=>4 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 1,
		.is_valid = false
	},
	{
		.d = {0xF0, 0x8C, 0xBC, 0x28},  // F0=>4 byte seq but 28 is an invalid secondary byte
		.codepoints = {},
		.idx_init_invalid = 3,
		.is_valid = false
	},
	{
		.d = {0x0D, 0x0A, 0xF0, 0x8C, 0xBC, 0x28},  // F0=>4 byte seq but 28 is an invalid secondary byte
		.codepoints = {0x0D, 0x0A},
		.idx_init_invalid = 5,
		.is_valid = false
	},
};


//
// Single-byte test data
//

// Any byte that begins with 0, 110, 1110, or 11110 is valid
std::array<std::uint8_t> valid_leading_bytes {
	0b00000000, 0b00000001, 0b00000010, 0b00000011, 0b00000100,
	0b00000101, 0b00000110, 0b00000111, 0b00001000, 0b00001001,
	0b00001010, 0b00001011, 0b00001100, 0b00001101, 0b00001110,
	0b00001111, 0b00010000, 0b00010001, 0b00010010, 0b00010011,
	0b00010100, 0b00010101, 0b00010110, 0b00010111, 0b00011000,
	0b00011001, 0b00011010, 0b00011011, 0b00011100, 0b00011101,
	0b00011110, 0b00011111, 0b00100000, 0b00100001, 0b00100010,
	0b00100011, 0b00100100, 0b00100101, 0b00100110, 0b00100111,
	0b00101000, 0b00101001, 0b00101010, 0b00101011, 0b00101100,
	0b00101101, 0b00101110, 0b00101111, 0b00110000, 0b00110001,
	0b00110010, 0b00110011, 0b00110100, 0b00110101, 0b00110110,
	0b00110111, 0b00111000, 0b00111001, 0b00111010, 0b00111011,
	0b00111100, 0b00111101, 0b00111110, 0b00111111, 0b01000000,
	0b01000001, 0b01000010, 0b01000011, 0b01000100, 0b01000101,
	0b01000110, 0b01000111, 0b01001000, 0b01001001, 0b01001010,
	0b01001011, 0b01001100, 0b01001101, 0b01001110, 0b01001111,
	0b01010000, 0b01010001, 0b01010010, 0b01010011, 0b01010100,
	0b01010101, 0b01010110, 0b01010111, 0b01011000, 0b01011001,
	0b01011010, 0b01011011, 0b01011100, 0b01011101, 0b01011110,
	0b01011111, 0b01100000, 0b01100001, 0b01100010, 0b01100011,
	0b01100100, 0b01100101, 0b01100110, 0b01100111, 0b01101000,
	0b01101001, 0b01101010, 0b01101011, 0b01101100, 0b01101101,
	0b01101110, 0b01101111, 0b01110000, 0b01110001, 0b01110010,
	0b01110011, 0b01110100, 0b01110101, 0b01110110, 0b01110111,
	0b01111000, 0b01111001, 0b01111010, 0b01111011, 0b01111100,
	0b01111101, 0b01111110, 0b01111111, 0b11000000, 0b11000001,
	0b11000010, 0b11000011, 0b11000100, 0b11000101, 0b11000110,
	0b11000111, 0b11001000, 0b11001001, 0b11001010, 0b11001011,
	0b11001100, 0b11001101, 0b11001110, 0b11001111, 0b11010000,
	0b11010001, 0b11010010, 0b11010011, 0b11010100, 0b11010101,
	0b11010110, 0b11010111, 0b11011000, 0b11011001, 0b11011010,
	0b11011011, 0b11011100, 0b11011101, 0b11011110, 0b11011111,
	0b11100000, 0b11100001, 0b11100010, 0b11100011, 0b11100100,
	0b11100101, 0b11100110, 0b11100111, 0b11101000, 0b11101001,
	0b11101010, 0b11101011, 0b11101100, 0b11101101, 0b11101110,
	0b11101111, 0b11110000, 0b11110001, 0b11110010, 0b11110011,
	0b11110100, 0b11110101, 0b11110110, 0b11110111
};

// Any byte that does not begin with 0, 110, 1110, or 11110 is invalid as a leading byte
std::array<std::uint8_t> invalid_leading_bytes {
	0b10000000, 0b10000001, 0b10000010, 0b10000011, 0b10000100,
	0b10000101, 0b10000110, 0b10000111, 0b10001000, 0b10001001,
	0b10001010, 0b10001011, 0b10001100, 0b10001101, 0b10001110,
	0b10001111, 0b10010000, 0b10010001, 0b10010010, 0b10010011,
	0b10010100, 0b10010101, 0b10010110, 0b10010111, 0b10011000,
	0b10011001, 0b10011010, 0b10011011, 0b10011100, 0b10011101,
	0b10011110, 0b10011111, 0b10100000, 0b10100001, 0b10100010,
	0b10100011, 0b10100100, 0b10100101, 0b10100110, 0b10100111,
	0b10101000, 0b10101001, 0b10101010, 0b10101011, 0b10101100,
	0b10101101, 0b10101110, 0b10101111, 0b10110000, 0b10110001,
	0b10110010, 0b10110011, 0b10110100, 0b10110101, 0b10110110,
	0b10110111, 0b10111000, 0b10111001, 0b10111010, 0b10111011,
	0b10111100, 0b10111101, 0b10111110, 0b10111111, 0b11111000,
	0b11111001, 0b11111010, 0b11111011, 0b11111100, 0b11111101,
	0b11111110, 0b11111111
};

// The two arrays above together contain every single valid and invalid byte
static_assert(valid_leading_bytes.size()+invalid_leading_bytes.size() == std::numeric_limits<std::uint8_t>::max());

// Any byte that begins with '10' is a valid trailing byte
std::array<std::uint8_t> valid_trailing_bytes {
	0b10000000, 0b10000001, 0b10000010, 0b10000011, 0b10000100,
	0b10000101, 0b10000110, 0b10000111, 0b10001000, 0b10001001,
	0b10001010, 0b10001011, 0b10001100, 0b10001101, 0b10001110,
	0b10001111, 0b10010000, 0b10010001, 0b10010010, 0b10010011,
	0b10010100, 0b10010101, 0b10010110, 0b10010111, 0b10011000,
	0b10011001, 0b10011010, 0b10011011, 0b10011100, 0b10011101,
	0b10011110, 0b10011111, 0b10100000, 0b10100001, 0b10100010,
	0b10100011, 0b10100100, 0b10100101, 0b10100110, 0b10100111,
	0b10101000, 0b10101001, 0b10101010, 0b10101011, 0b10101100,
	0b10101101, 0b10101110, 0b10101111, 0b10110000, 0b10110001,
	0b10110010, 0b10110011, 0b10110100, 0b10110101, 0b10110110,
	0b10110111, 0b10111000, 0b10111001, 0b10111010, 0b10111011,
	0b10111100, 0b10111101, 0b10111110, 0b10111111
};

// Any byte that does not begin with '10' is invalid as a trailing byte
std::array<std::uint8_t> invalid_trailing_bytes {
	0b00000000, 0b00000001, 0b00000010, 0b00000011, 0b00000100,
	0b00000101, 0b00000110, 0b00000111, 0b00001000, 0b00001001,
	0b00001010, 0b00001011, 0b00001100, 0b00001101, 0b00001110,
	0b00001111, 0b00010000, 0b00010001, 0b00010010, 0b00010011,
	0b00010100, 0b00010101, 0b00010110, 0b00010111, 0b00011000,
	0b00011001, 0b00011010, 0b00011011, 0b00011100, 0b00011101,
	0b00011110, 0b00011111, 0b00100000, 0b00100001, 0b00100010,
	0b00100011, 0b00100100, 0b00100101, 0b00100110, 0b00100111,
	0b00101000, 0b00101001, 0b00101010, 0b00101011, 0b00101100,
	0b00101101, 0b00101110, 0b00101111, 0b00110000, 0b00110001,
	0b00110010, 0b00110011, 0b00110100, 0b00110101, 0b00110110,
	0b00110111, 0b00111000, 0b00111001, 0b00111010, 0b00111011,
	0b00111100, 0b00111101, 0b00111110, 0b00111111, 0b01000000,
	0b01000001, 0b01000010, 0b01000011, 0b01000100, 0b01000101,
	0b01000110, 0b01000111, 0b01001000, 0b01001001, 0b01001010,
	0b01001011, 0b01001100, 0b01001101, 0b01001110, 0b01001111,
	0b01010000, 0b01010001, 0b01010010, 0b01010011, 0b01010100,
	0b01010101, 0b01010110, 0b01010111, 0b01011000, 0b01011001,
	0b01011010, 0b01011011, 0b01011100, 0b01011101, 0b01011110,
	0b01011111, 0b01100000, 0b01100001, 0b01100010, 0b01100011,
	0b01100100, 0b01100101, 0b01100110, 0b01100111, 0b01101000,
	0b01101001, 0b01101010, 0b01101011, 0b01101100, 0b01101101,
	0b01101110, 0b01101111, 0b01110000, 0b01110001, 0b01110010,
	0b01110011, 0b01110100, 0b01110101, 0b01110110, 0b01110111,
	0b01111000, 0b01111001, 0b01111010, 0b01111011, 0b01111100,
	0b01111101, 0b01111110, 0b01111111, 0b11000000, 0b11000001,
	0b11000010, 0b11000011, 0b11000100, 0b11000101, 0b11000110,
	0b11000111, 0b11001000, 0b11001001, 0b11001010, 0b11001011,
	0b11001100, 0b11001101, 0b11001110, 0b11001111, 0b11010000,
	0b11010001, 0b11010010, 0b11010011, 0b11010100, 0b11010101,
	0b11010110, 0b11010111, 0b11011000, 0b11011001, 0b11011010,
	0b11011011, 0b11011100, 0b11011101, 0b11011110, 0b11011111,
	0b11100000, 0b11100001, 0b11100010, 0b11100011, 0b11100100,
	0b11100101, 0b11100110, 0b11100111, 0b11101000, 0b11101001,
	0b11101010, 0b11101011, 0b11101100, 0b11101101, 0b11101110,
	0b11101111, 0b11110000, 0b11110001, 0b11110010, 0b11110011,
	0b11110100, 0b11110101, 0b11110110, 0b11110111, 0b11111000,
	0b11111001, 0b11111010, 0b11111011, 0b11111100, 0b11111101,
	0b11111110, 0b11111111
};

// The two arrays above together contain every single valid and invalid byte
static_assert(valid_trailing_bytes.size()+invalid_trailing_bytes.size() == std::numeric_limits<std::uint8_t>::max());


